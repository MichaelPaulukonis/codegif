<html>
<head>
	<style>
		input[type=number] {
			width: 50px;
		}
		label {
			margin-left: 10px;
		}
	</style>
</head>
<body>
	<h1>code2gif</h1>
	<ol>
		<li>Write some HTML5 canvas code</li>
		<li>Create perfectly looping gif</li>
		<li>???</li>
		<li>Profit!</li>
	</ol>
	<script src="b64.js"></script>
	<script src="LZWEncoder.js"></script>
	<script src="NeuQuant.js"></script>
	<script src="GIFEncoder.js"></script>
	<canvas id="bitmap"></canvas>
	<img id="image"><br>

	<p>
		<input id="downloadButton" type="submit" value="Download GIF"/>

		<label>Frames</label>
		<input id="frameCount" type="number" value="30"/>

		<label>Delay</label>
		<input id="delay" type="number" min="1" value="16"/>

		<label>Width</label>
		<input id="width" type="number" min="1" value="150"/>

		<label>Height</label>
		<input id="height" type="number" min="1" value="150"/>

		<input id="normalize" type="checkbox" value="1" checked/>
		<label>Normalized coords</label>

	</p>

<script>
function draw(t){
	beginPath();
	fillStyle = "red";
	arc(0.5,0.5,max(0,0.1+0.1*(1+sin(2*PI*t))),0,PI*2,true);
	fill();
}
</script>

<script id="sample2" type="x-lol">
function draw(t){
	translate(0.5,0.5);
	var s = (2+sin(2*PI*t))*0.4;
	scale(s,s);
	beginPath();
	fillStyle = "red";

	scale(1/150, 1/150);
	translate(-75,-75);
	moveTo(75, 40);
	bezierCurveTo(75, 37, 70, 25, 50, 25);
	bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
	bezierCurveTo(20, 80, 40, 102, 75, 120);
	bezierCurveTo(110, 102, 130, 80, 130, 62.5);
	bezierCurveTo(130, 62.5, 130, 25, 100, 25);
	bezierCurveTo(85, 25, 75, 37, 75, 40);

	fill();
}
</script>

<div id="container" style="width:100%;height:50%;"></div>
<script src="monaco-editor/min/vs/loader.js"></script>
<div id="cheatSheet">
	<h2>Cheat sheet</h2>
	<ul>
	<li>save()</li>
	<li>restore()</li>

	<li>scale(x,y)</li>
	<li>rotate(angle)</li>
	<li>translate(x,y)</li>
	<li>transform(m11,m12,m21,m22,dx,dy)</li>
	<li>setTransform(m11,m12,m21,m22,dx,dy)</li>

	<li>globalAlpha=1.0</li>
	<li>globalCompositeOperation='source-over'</li>

	<li>lineWidth=1.0</li>
	<li>lineCap='butt'</li>
	<li>lineJoin='miter'</li>
	<li>miterLimit=10</li>

	<li>strokeStyle='black'</li>
	<li>fillStyle='black'</li>
	<li>shadowOffsetX=0.0</li>
	<li>shadowOffsetY=0.0</li>
	<li>shadowBlur=0.0</li>
	<li>shadowColor='transparent black'</li>

	<li>g=createLinearGradient(x0,y0,x1,y1)</li>
	<li>g=createRadialGradient(x0,y0,r0,x1,y1,r1)</li>
	<li>p=createPattern(image,repetition)</li>

	<li>addColorStop(offset, color)</li>

	<li>beginPath()</li>
	<li>closePath()</li>
	<li>fill()</li>
	<li>stroke()</li>
	<li>clip()</li>
	<li>moveTo(x, y)</li>
	<li>lineTo(x, y)</li>
	<li>quadraticCurveTo(cpx, cpy, x, y)</li>
	<li>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</li>
	<li>arcTo(x1, y1, x2, y2, radius)</li>
	<li>arc(x, y, radius, startAngle, endAngle, anticlockwise)</li>
	<li>rect(x, y, w, h)</li>
	<li>b = isPointInPath(x, y)</li>

	<li>clearRect(x, y, w, h)</li>
	<li>fillRect(x, y, w, h)</li>
	<li>strokeRect(x, y, w, h)</li>

	<li>font='10px sans-serif'</li>
	<li>textAlign='start'</li>
	<li>textBaseline='alphabetic'</li>

	<li>fillText(text, x, y, [maxWidth])</li>
	<li>strokeText(text, x, y, [maxWidth])</li>
	<li>m = measureText(text)</li>

	</ul>
</div>

<script>
function updateCode(code){

	// Take all from ctx and put on global
	for(var key in ctx){
		(function(keyScoped){
			try {
				if(typeof ctx[keyScoped] === 'function'){
					window[keyScoped] = function(){
						return ctx[keyScoped].apply(ctx,arguments);
					};
				} else {
					Object.defineProperty(window, keyScoped, {
						get: function(){ return ctx[keyScoped]; },
						set: function(value){ ctx[keyScoped] = value; },
					});
				}
			} catch(err){
				//console.error(err)
			}
		})(key);
	}

	// Math shortcuts
	var keys = Object.getOwnPropertyNames(Math);
	for(var i=0; i<keys.length; i++){
		var key = keys[i];
		window[key] = Math[key];
	}

	eval(code);
	window.draw = draw; // Update the current one
}

(function(){
	var editor;
	var canvas = document.getElementById('bitmap');
	var ctx = window.ctx = canvas.getContext('2d');
	var inputs = {};
	var normalize = false;
	inputs.frameCount = document.getElementById('frameCount');
	inputs.delay = document.getElementById('delay');
	inputs.width = document.getElementById('width');
	inputs.height = document.getElementById('height');
	inputs.normalize = document.getElementById('normalize');

	var working = false;
	function setWorking(isWorking){
		working = isWorking;
		var style = document.getElementById('image').style;
		style.border = working ? 'solid 3px red' : 'solid 3px white';

	}
	var encoder = new GIFEncoder();
	var frame = 0, frameCount = 0;
	var code;

	function makeGif(){
		update();

		var frame = 0;
		var frameCount = parseInt(inputs.frameCount.value, 10);
		var delay = parseInt(inputs.delay.value, 10);
		var width = parseInt(inputs.width.value, 10);
		var height = parseInt(inputs.height.value, 10);
		var normalize = inputs.normalize.checked;

		var canvas = document.createElement('canvas');
		canvas.width = width;
		canvas.height = height;
		var ctx = window.ctx = canvas.getContext('2d');

		encoder.setRepeat(0); //auto-loop
		encoder.setDelay(delay);
		encoder.setSize(width,height);
		encoder.start();

		if(normalize){
			ctx.scale(width,height);
		}

		for(var i=0;i<frameCount; i++){
			console.log('Adding frame ' + frame + '...');

			ctx.save();
			ctx.fillStyle = "rgb(255,255,255)";
			if(normalize)
				ctx.fillRect(0,0,1,1);
			else
				ctx.fillRect(0,0,width,height);

			try {
				window.draw(frame/frameCount);
			} catch(err){
				console.error(err);
			}

			encoder.addFrame(ctx);

			frame++;

			ctx.restore();
		}

		encoder.finish();
		//document.getElementById('image').src = 'data:image/gif;base64,'+encode64(encoder.stream().getData());
		encoder.download();
	}

	// Init editor
	require.config({ paths: { 'vs': 'monaco-editor/min/vs' }});
	require(['vs/editor/editor.main'], function() {
		editor = monaco.editor.create(document.getElementById('container'), {
			value: draw.toString(),
			language: 'javascript',
			theme: 'vs'
		});
		init();
	});

	function debounce(func, wait, immediate) {
		var timeout;
		return function() {
			var context = this, args = arguments;
			var later = function() {
				timeout = null;
				if (!immediate) func.apply(context, args);
			};
			var callNow = immediate && !timeout;
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
			if (callNow) func.apply(context, args);
		};
	};

	var animationLoop = null;
	function update(){

		code = editor.getValue();
		try {
			updateCode(code);
		} catch(err){
			console.error(err);
			return;
		}

		canvas.width = parseInt(inputs.width.value, 10);
		canvas.height = parseInt(inputs.height.value, 10);
		delay = parseInt(inputs.delay.value, 10);
		frameCount = parseInt(inputs.frameCount.value, 10);
		if(animationLoop!==null){
			clearInterval(animationLoop);
		}
		animationLoop = setInterval(updateAnimationCanvas, delay);
	}

	var animationFrame = 0;
	function updateAnimationCanvas(){
		window.ctx = canvas.getContext('2d');

		ctx.save();
		normalize = inputs.normalize.checked;
		if(normalize){
			ctx.scale(canvas.width,canvas.height);
		}

		ctx.fillStyle = "rgb(255,255,255)";
		if(normalize)
			ctx.fillRect(0,0,1,1);
		else
			ctx.fillRect(0,0,canvas.width,canvas.height);

		try {
			window.draw((animationFrame % frameCount) / frameCount);
		} catch(err){
			console.error(err);
		}

		ctx.restore();

		animationFrame++;
	}

	function init(){
		editor.onDidChangeModelContent(function(){
			update();
		});

		window.addEventListener('resize', function(){
			editor.layout();
		});

		for(var name in inputs){
			inputs[name].addEventListener('change', update);
			inputs[name].addEventListener('keydown', update);
		}
		document.getElementById('downloadButton').addEventListener('click', function(){
			makeGif();
		});

		update();
	}
})();
</script>

</body>
</html>