<html>
<head>
	<style>
		input[type=number] {
			width: 50px;
		}
		label {
			margin-left: 10px;
		}
	</style>
</head>
<body>
	<h1>js to gif</h1>
	<ol>
		<li>Write some HTML5 canvas code</li>
		<li>Download gif</li>
		<li>???</li>
		<li>Profit!</li>
	</ol>
	<script src="b64.js"></script>
	<script src="LZWEncoder.js"></script>
	<script src="NeuQuant.js"></script>
	<script src="GIFEncoder.js"></script>
	<canvas id="bitmap" style="display:none"></canvas>
	<img id="image"><br>

	<p>
		<input id="downloadButton" type="submit" value="Download GIF"/>

		<label>Frames</label>
		<input id="frameCount" type="number" value="30"/>

		<label>Delay</label>
		<input id="delay" type="number" min="1" value="16"/>

		<label>Width</label>
		<input id="width" type="number" min="1" value="150"/>

		<label>Height</label>
		<input id="height" type="number" min="1" value="150"/>

		<input id="normalize" type="checkbox" value="1" checked/>
		<label>Normalized coords</label>

	</p>

<script>
function draw(t){
	beginPath();
	fillStyle = "red";
	arc(0.5,0.5,max(0,0.1+0.1*(1+sin(2*PI*t))),0,PI*2,true);
	fill();
}
</script>

<div id="container" style="width:100%;height:50%;"></div>
<script src="monaco-editor/min/vs/loader.js"></script>
<script>
function evalCode(code){

	// Take all from ctx and put on global
	for(var key in ctx){
		(function(keyScoped){
			try {
				if(typeof ctx[keyScoped] === 'function'){
					window[keyScoped] = function(){
						return ctx[keyScoped].apply(ctx,arguments);
					};
				} else {
					Object.defineProperty(window, keyScoped, {
						get: function(){ return ctx[keyScoped]; },
						set: function(value){ ctx[keyScoped] = value; },
					});
				}
			} catch(err){
				//console.error(err)
			}
		})(key);
	}

	// Math shortcuts
	var keys = Object.getOwnPropertyNames(Math);
	for(var i=0; i<keys.length; i++){
		var key = keys[i];
		window[key] = Math[key];
	}

	eval(code);
	window.draw = draw; // Update the current one
}

(function(){
	var editor;
	var canvas = document.getElementById('bitmap');
	var ctx = window.ctx = canvas.getContext('2d');
	var inputs = {};
	var normalize = false;
	inputs.frameCount = document.getElementById('frameCount');
	inputs.delay = document.getElementById('delay');
	inputs.width = document.getElementById('width');
	inputs.height = document.getElementById('height');
	inputs.normalize = document.getElementById('normalize');

	var working = false;
	function setWorking(isWorking){
		working = isWorking;
		var style = document.getElementById('image').style;
		style.border = working ? 'solid 3px red' : 'solid 3px white';

	}
	var encoder = new GIFEncoder();
	var frame = 0, frameCount = 0;
	var code;
	var dirty = false;

	setInterval(function(){
		if(!working) return;

		ctx.fillStyle = "rgb(255,255,255)";
		if(normalize) ctx.fillRect(0,0,1,1); else ctx.fillRect(0,0,width,height);
		try {
			window.draw(frame/frameCount);
		} catch(err){
			console.error(err);
			setWorking(false);
			ctx.restore();
			encoder.finish();
			return;
		}
		console.log('Adding frame ' + frame + '...');
		encoder.addFrame(ctx);

		frame++;
		if(frame === frameCount){
			setWorking(false);
			ctx.restore();
			encoder.finish();
			document.getElementById('image').src = 'data:image/gif;base64,'+encode64(encoder.stream().getData());
			console.log('end');
			if(dirty){
				dirty = false;
				updateGif();
			}
		}

	}, 50);

	function updateGif(){
		if(working){
			dirty = true; // update once more when done
			return;
		}

		code = editor.getValue();
		try {
			evalCode(code);
		} catch(err){
			console.error(err);
			return;
		}

		frame = 0;
		frameCount = parseInt(inputs.frameCount.value, 10);
		var delay = parseInt(inputs.delay.value, 10);
		var width = parseInt(inputs.width.value, 10);
		var height = parseInt(inputs.height.value, 10);
		normalize = inputs.normalize.checked;

		encoder.setRepeat(0); //auto-loop
		encoder.setDelay(delay);
		canvas.width = width;
		canvas.height = height;
		encoder.setSize(width,height);
		encoder.start();
		console.log('start');
		setWorking(true);

		ctx.save();
		if(normalize){
			ctx.scale(width,height);
		}
	}

	require.config({ paths: { 'vs': 'monaco-editor/min/vs' }});
	require(['vs/editor/editor.main'], function() {
		editor = monaco.editor.create(document.getElementById('container'), {
			value: draw.toString(),
			language: 'javascript',
			theme: 'vs-dark'
		});
		init();
	});

	function debounce(func, wait, immediate) {
		var timeout;
		return function() {
			var context = this, args = arguments;
			var later = function() {
				timeout = null;
				if (!immediate) func.apply(context, args);
			};
			var callNow = immediate && !timeout;
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
			if (callNow) func.apply(context, args);
		};
	};

	var updateGifDebounced = debounce(updateGif, 1000);
	function init(){
		editor.onDidChangeModelContent(function(){
			updateGif();
		});
		updateGif();

		for(var name in inputs){
			inputs[name].addEventListener('change', updateGif);
			inputs[name].addEventListener('keydown', updateGif);
		}
		document.getElementById('downloadButton').addEventListener('click', function(){
			encoder.download();
		});
	}
})();
</script>

</body>
</html>